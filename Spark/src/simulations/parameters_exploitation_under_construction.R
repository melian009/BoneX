# =============================================================================
# SIMPLE EXPLORATION WRAPPER
# Uses your existing functions, just varies parameters and stores results
# =============================================================================

library(dplyr)

# Main function: varies all parameters and returns a dataframe
explore_parameters <- function(
    # Network structures to test
  mut_structures = c("random", "nested", "modular"),
  serv_structures = c("random", "nested", "modular"),
  serv_distributions = c("uniform", "lognormal", "beta"),
  
  # Network sizes
  n_species = 20,
  n_services = 5,
  
  # Environmental parameters (can be vectors)
  A_min = 1,
  A_max = 10,
  w_min = 2,
  w_max = 5,
  t_max = 100,
  
  # Cost/benefit parameters (can be vectors)
  B_shape1 = 0.5,
  B_shape2 = 0.5,
  Ce_shape1 = 0.5,
  Ce_shape2 = 0.5,
  Cp_shape1 = 0.5,
  Cp_shape2 = 0.5,
  Cp_multiplier = 0.2,
  
  # Zi parameters
  zi_min = 1,
  zi_max = 10,
  
  # Network parameters (can be vectors)
  connectance_mut = 0.3,
  connectance_serv = 0.3,
  n_modules_mut = 3,
  n_modules_serv = 3,
  internal_connectance_mut = 0.8, 
  external_connectance_mut = 0.05,
  internal_connectance_serv = 0.8, 
  external_connectance_serv = 0.05,
  nested_degree_mut = 0.8,
  nested_degree_serv = 0.8,
  nested_min_connectance_mut = 0.1,
  nested_max_connectance_mut = 0.9,
  nested_min_connectance_serv = 0.1,
  nested_max_connectance_serv = 0.9,
  
  # Replicates
  n_replicates = 5,
  seed = 123
) {
  
  # Create grid with all combinations
  params <- expand.grid(
    mut_struct = mut_structures,
    serv_struct = serv_structures,
    serv_dist = serv_distributions,
    A_min = A_min,
    A_max = A_max,
    w_min = w_min,
    w_max = w_max,
    B_sh1 = B_shape1,
    B_sh2 = B_shape2,
    Ce_sh1 = Ce_shape1,
    Ce_sh2 = Ce_shape2,
    Cp_sh1 = Cp_shape1,
    Cp_sh2 = Cp_shape2,
    Cp_mult = Cp_multiplier,
    conn_mut = connectance_mut,
    conn_serv = connectance_serv,
    n_mod_mut = n_modules_mut,
    n_mod_serv = n_modules_serv,
    int_conn_mut = internal_connectance_mut, 
    ext_conn_mut = external_connectance_mut,
    int_conn_serv = internal_connectance_serv, 
    ext_conn_serv = external_connectance_serv,
    nest_dg_mut = nested_degree_mut,
    nest_dg_serv = nested_degree_serv,
    nest_min_conn_mut = nested_min_connectance_mut,
    nest_max_conn_mut = nested_max_connectance_mut,
    nest_min_conn_serv = nested_min_connectance_serv,
    nest_max_conn_serv = nested_max_connectance_serv,
    replicate = 1:n_replicates,
    stringsAsFactors = FALSE
  )
  
  n_total <- nrow(params)
  cat(sprintf("\nTotal simulations: %d\n", n_total))
  cat("Running simulations...\n\n")
  
  # Store results
  results_list <- list()
  
  # Loop through all combinations
  for(i in 1:n_total) {
    
    if(i %% 50 == 0 | i == n_total) {
      cat(sprintf("  Progress: %d/%d (%.1f%%)\n", i, n_total, (i/n_total)*100))
    }
    
    set.seed(seed + i)
    p <- params[i, ]
    
    # YOUR interaction_networks function
    mut_net <- interaction_networks(
      sp_n = n_species,
      type = as.character(p$mut_struct),
      connectance = p$conn_mut,
      n_modules = p$n_mod_mut,
      internal_connectance = p$int_conn_mut, 
      external_connectance = p$ext_conn_mut,
      nested_degree = p$nest_dg_mut,
      nested_min_connectance = p$nest_min_conn_mut,
      nested_max_connectance = p$nest_max_conn_mut
    )
    
    # YOUR ecosystem_services_network function
    serv_net <- ecosystem_services_network(
      sp_n = n_species,
      services_n = n_services,
      type = as.character(p$serv_struct),
      distribution = as.character(p$serv_dist),
      connectance = p$conn_serv,
      n_modules = p$n_mod_serv,
      internal_connectance = p$int_conn_serv, 
      external_connectance = p$ext_conn_serv,
      nested_degree = p$nest_dg_serv,
      nested_min_connectance = p$nest_min_conn_serv,
      nested_max_connectance = p$nest_max_conn_serv
    )
    
    # YOUR environment function
    theta <- environment(p$A_min, p$A_max, p$w_min, p$w_max, t_max = t_max)
    
    # Generate species parameters
    B_vec <- rbeta(n_species, p$B_sh1, p$B_sh2)
    Ce_vec <- rbeta(n_species, p$Ce_sh1, p$Ce_sh2)
    Cp_vec <- rbeta(n_species, p$Cp_sh1, p$Cp_sh2) * p$Cp_mult
    zi <- runif(n_species, zi_min, zi_max)
    
    # YOUR simulation function
    dynamics <- simulation(mut_net, B_vec, Ce_vec, Cp_vec, zi, theta)
    
    # YOUR ecosystem function
    services <- ecosystem(dynamics, serv_net)
    
    # Store results in dataframe row
    results_list[[i]] <- data.frame(
      # Simulation ID
      sim_id = i,
      
      # Parameters
      mut_structure = p$mut_struct,
      serv_structure = p$serv_struct,
      serv_distribution = p$serv_dist,
      A_min = p$A_min,
      A_max = p$A_max,
      w_min = p$w_min,
      w_max = p$w_max,
      env_amplitude = p$A_max - p$A_min,
      env_frequency = p$w_max - p$w_min,
      B_shape1 = p$B_sh1,
      B_shape2 = p$B_sh2,
      Ce_shape1 = p$Ce_sh1,
      Ce_shape2 = p$Ce_sh2,
      Cp_shape1 = p$Cp_sh1,
      Cp_shape2 = p$Cp_sh2,
      Cp_multiplier = p$Cp_mult,
      connectance_mut = p$conn_mut,
      connectance_serv = p$conn_serv,
      n_modules_mut = p$n_mod_mut,
      n_modules_serv = p$n_mod_serv,
      int_conn_mut = p$int_conn_mut, 
      ext_conn_mut = p$ext_conn_mut,
      nest_dg_mut = p$nest_dg_mut,
      nest_min_conn_mut = p$nest_min_conn_mut,
      nest_max_conn_mut = p$nest_max_conn_mut,
      int_conn_serv = p$int_conn_serv, 
      ext_conn_serv = p$ext_conn_serv,
      nest_dg_serv = p$nest_dg_serv,
      nest_min_conn_serv = p$nest_min_conn_serv,
      nest_max_conn_serv = p$nest_max_conn_serv,
      replicate = p$replicate,
      
      # Results: species dynamics
      persistence_species = dynamics$prop_active_species,
      persistence_interactions = dynamics$prop_remaining_interactions,
      n_species_final = sum(dynamics$final_state),
      time_to_convergence = nrow(dynamics$state_history),
      
      # Results: ecosystem services
      services_initial = sum(services$E_initial),
      services_final = sum(services$E_final),
      services_loss = sum(services$delta_E),
      services_loss_relative = sum(services$delta_E) / sum(services$E_initial),
      
      # Add history in columns type list
      prop_species_history = I(list(dynamics$prop_species_history)),
      prop_interactions_history = I(list(dynamics$prop_interactions_history)),
      degree_history = I(list(dynamics$degree_history)),
    
      
      # degree (initial and mean)
      initial_degree = I(list(dynamics$degree_history[1, ])),
      mean_degree_initial = mean(dynamics$degree_history[1, ], na.rm = TRUE),
      
      stringsAsFactors = FALSE
    )
  }
  
  # Combine all results into one dataframe
  results_df <- bind_rows(results_list)
  
  cat(sprintf("\nCompleted! %d simulations.\n\n", nrow(results_df)))
  
  return(results_df)
}


# =============================================================================
# USAGE EXAMPLES
# =============================================================================

# Example 1: Quick test (few combinations)
test <- explore_parameters(
  mut_structures = c("random", "nested"),
  serv_structures = c("random"),
  serv_distributions = c("uniform"),
  A_min = c(1, 5),
  A_max = 10,
  w_min = 1,
  w_max = 3,
  n_replicates = 2
)

# View results
View(test)
head(test)
# prop_species_history da primeira simulação
test$prop_species_history[[1]]

# degree_history da primeira simulação
test$degree_history[[1]]

# initial_degree da primeira simulação
test$initial_degree[[1]]

# Exemplo para prop_species_history
library(dplyr)
library(tidyr)

prop_species_all <- test %>%
  select(sim_id, prop_species_history) %>%
  unnest(cols = c(prop_species_history))
prop_species_all

test$final_prop_species <- sapply(test$prop_species_history, function(x) tail(x, 1))
test$final_prop_species

# pega a média do grau inicial
test$mean_initial_degree <- sapply(test$degree_history, function(x) mean(x[1, ], na.rm = TRUE))
test$mean_initial_degree

# Supondo que as colunas em lista sejam prop_species_history e prop_interactions_history
cols_list <- c("prop_species_history", "prop_interactions_history", "degree_history", "initial_degree")

mean_by_time_all <- lapply(cols_list, function(col) {
  long <- test %>%
    select(sim_id, all_of(col)) %>%
    unnest(all_of(col)) %>%
    group_by(sim_id) %>%
    mutate(time = row_number()) %>%
    ungroup() %>%
    group_by(time) %>%
    summarise(mean_value = mean(.data[[col]], na.rm = TRUE))
  return(long)
})

names(mean_by_time_all) <- cols_list

# Média por tempo de prop_species_history
mean_by_time_all[["prop_species_history"]]

# Média por tempo de prop_interactions_history
mean_by_time_all[["prop_interactions_history"]]

# Média por tempo de degree_history
mean_by_time_all[["degree_history"]]

# Média por tempo de initial_degree
mean_by_time_all[["initial_degree"]]


# Example 2: Vary environmental parameters
env_exploration <- explore_parameters(
  mut_structures = c("random", "nested", "modular"),
  serv_structures = c("random", "nested"),
  serv_distributions = c("uniform", "lognormal"),
  A_min = c(1, 3, 5),           # 3 values
  A_max = c(5, 8, 10),          # 3 values
  w_min = c(0.5, 1, 2),         # 3 values
  w_max = c(2, 3, 5),           # 3 values
  n_replicates = 5
)

# Save
write.csv(env_exploration, "results.csv", row.names = FALSE)
saveRDS(env_exploration, "results.rds")


# Example 3: Vary cost/benefit parameters
cost_exploration <- explore_parameters(
  mut_structures = c("nested", "modular"),
  serv_structures = c("nested"),
  A_min = 1,
  A_max = 10,
  w_min = 1,
  w_max = 5,
  Cp_multiplier = c(0.1, 0.2, 0.3, 0.4),  # Vary physiological cost
  B_shape1 = c(0.3, 0.5, 0.7),            # Vary benefit distribution
  n_replicates = 10
)


# Example 4: Vary network parameters
network_exploration <- explore_parameters(
  mut_structures = c("modular"),
  serv_structures = c("modular"),
  connectance_mut = c(0.1, 0.3, 0.5),     # Vary connectance
  connectance_serv = c(0.2, 0.4),
  n_modules_mut = c(2, 3, 4),              # Vary modularity
  n_modules_serv = c(2, 3, 4),
  A_min = 1,
  A_max = 10,
  w_min = 1,
  w_max = 5,
  n_replicates = 5
)


# Example 5: Full exploration (many combinations!)
full_results <- explore_parameters(
  mut_structures = c("random", "nested", "modular", "star", "path"),
  serv_structures = c("random", "nested", "modular", "star", "path"),
  serv_distributions = c("uniform", "lognormal", "beta"),
  A_min = c(1, 3, 5),
  A_max = c(5, 8, 10),
  w_min = c(0.5, 1, 2),
  w_max = c(2, 3, 5),
  Cp_multiplier = c(0.1, 0.2, 0.3),
  n_replicates = 5
)
# This creates: 5*5*3*3*3*3*3*3*5 = 91,125 simulations!


# =============================================================================
# QUICK ANALYSIS FUNCTIONS
# =============================================================================

# Summary by structure
summarize_by_structure <- function(df) {
  df %>%
    group_by(mut_structure, serv_structure) %>%
    summarise(
      n = n(),
      mean_persistence = mean(persistence_species),
      sd_persistence = sd(persistence_species),
      mean_services_final = mean(services_final),
      mean_services_loss = mean(services_loss_relative),
      .groups = "drop"
    )
}

# Summary by environmental conditions
summarize_by_environment <- function(df) {
  df %>%
    group_by(env_amplitude, env_frequency) %>%
    summarise(
      n = n(),
      mean_persistence = mean(persistence_species),
      mean_services = mean(services_final),
      mean_loss = mean(services_loss_relative),
      .groups = "drop"
    )
}


# =============================================================================
# SIMPLE PLOTS
# =============================================================================

library(ggplot2)

# Plot persistence by structure
plot_persistence <- function(df) {
  ggplot(df, aes(x = mut_structure, y = persistence_species, 
                 fill = serv_structure)) +
    geom_boxplot() +
    theme_minimal() +
    labs(title = "Species Persistence by Network Structure",
         x = "Mutualism Structure", 
         y = "Proportion of Persistent Species")
}

# Plot environmental effects
plot_environment <- function(df) {
  ggplot(df, aes(x = env_amplitude, y = services_loss_relative, 
                 color = mut_structure)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "loess") +
    facet_wrap(~ serv_structure) +
    theme_minimal() +
    labs(title = "Environmental Impact on Services",
         x = "Environmental Amplitude",
         y = "Relative Services Loss")
}

# Plot persistence vs services
plot_correlation <- function(df) {
  ggplot(df, aes(x = persistence_species, y = services_final, 
                 color = mut_structure)) +
    geom_point(alpha = 0.6) +
    geom_smooth(method = "lm", se = FALSE) +
    theme_minimal() +
    labs(title = "Species Persistence vs Ecosystem Services",
         x = "Persistence", y = "Final Services")
}



################################################################################
# =============================================================================
# FUNÇÃO: EXPLORAÇÃO DE PARÂMETROS - VERSÃO 3 (SIMPLIFICADA)
# =============================================================================
# Grid focado em:
# - Estrutura da rede mutualista (nested, modular, random)
# - Quem provê serviços ecossistêmicos (core, periphery, random)

explore_parameters_v3 <- function(
    # -------------------------------------------
    # GRID PRINCIPAL (o que vamos variar)
    # -------------------------------------------
    mut_structures = c("nested", "modular", "random"),
    service_providers_options = c("core", "periphery", "random"),
    
    # -------------------------------------------
    # TAMANHOS DAS REDES (fixo ou pode variar)
    # -------------------------------------------
    n_group1 = 10,        # Número de plantas
    n_group2 = 15,        # Número de polinizadores
    n_services = 5,       # Número de serviços
    
    # -------------------------------------------
    # PARÂMETROS AMBIENTAIS (fixo ou pode variar)
    # -------------------------------------------
    A_min = 0,
    A_max = 0,
    w_min = 0,
    w_max = 0,
    t_max = 0,
    
    # -------------------------------------------
    # PARÂMETROS DE CUSTO/BENEFÍCIO
    # -------------------------------------------
    B_shape1 = 0.5,
    B_shape2 = 0.5,
    Ce_shape1 = 0.5,
    Ce_shape2 = 0.5,
    Cp_shape1 = 0,
    Cp_shape2 = 0,
    Cp_multiplier = 0,
    
    # -------------------------------------------
    # PARÂMETROS ZI (ótimo ambiental)
    # -------------------------------------------
    zi_min = 1,
    zi_max = 10,
    
    # -------------------------------------------
    # PARÂMETROS DA REDE MUTUALISTA
    # -------------------------------------------
    # Para RANDOM
    connectance_random = 0.3,
    
    # Para MODULAR
    n_modules = 3,
    internal_connectance_modular = 0.8,
    external_connectance_modular = 0.05,
    
    # Para NESTED
    nested_degree = 0.8,
    nested_min_connectance = 0.1,
    nested_max_connectance = 0.9,
    
    # -------------------------------------------
    # PARÂMETROS CORE/PERIPHERY
    # -------------------------------------------
    threshold_percentile = 0.5,  # 50% superior = core
    
    # -------------------------------------------
    # REPLICATAS
    # -------------------------------------------
    n_replicates = 5,
    seed = 123
) {
  
  # ---------------------------------------------------------------------------
  # CRIAR GRID DE COMBINAÇÕES
  # ---------------------------------------------------------------------------
  params <- expand.grid(
    mut_struct = mut_structures,
    service_prov = service_providers_options,
    replicate = 1:n_replicates,
    stringsAsFactors = FALSE
  )
  
  n_total <- nrow(params)
  n_species_total <- n_group1 + n_group2
  
  cat("\n===========================================================\n")
  cat("EXPLORAÇÃO DE PARÂMETROS - REDES MUTUALISTAS\n")
  cat("===========================================================\n\n")
  cat(sprintf("Estruturas de rede: %s\n", paste(mut_structures, collapse = ", ")))
  cat(sprintf("Provedores de serviços: %s\n", paste(service_providers_options, collapse = ", ")))
  cat(sprintf("Replicatas: %d\n", n_replicates))
  cat(sprintf("Total de simulações: %d\n", n_total))
  cat(sprintf("\nTamanho da rede: %d plantas + %d polinizadores = %d espécies\n", 
              n_group1, n_group2, n_species_total))
  cat(sprintf("Serviços ecossistêmicos: %d\n\n", n_services))
  cat("Iniciando simulações...\n\n")
  
  # ---------------------------------------------------------------------------
  # ARMAZENAR RESULTADOS
  # ---------------------------------------------------------------------------
  results_list <- list()
  
  # ---------------------------------------------------------------------------
  # LOOP PRINCIPAL
  # ---------------------------------------------------------------------------
  for(i in 1:n_total) {
    
    # Progresso
    if(i %% 10 == 0 | i == n_total) {
      cat(sprintf("  [%d/%d] %.1f%% completo\n", i, n_total, (i/n_total)*100))
    }
    
    # Definir seed para esta simulação
    set.seed(seed + i)
    
    # Pegar parâmetros desta linha
    p <- params[i, ]
    
    # -------------------------------------------------------------------------
    # PASSO 1: CRIAR REDE MUTUALISTA BIPARTIDA
    # -------------------------------------------------------------------------
    if(p$mut_struct == "random") {
      bipartite_net <- mutualistic_network_bipartite(
        n_group1 = n_group1,
        n_group2 = n_group2,
        type = "random",
        connectance = connectance_random
      )
    } else if(p$mut_struct == "modular") {
      bipartite_net <- mutualistic_network_bipartite(
        n_group1 = n_group1,
        n_group2 = n_group2,
        type = "modular",
        n_modules = n_modules,
        internal_connectance = internal_connectance_modular,
        external_connectance = external_connectance_modular
      )
    } else if(p$mut_struct == "nested") {
      bipartite_net <- mutualistic_network_bipartite(
        n_group1 = n_group1,
        n_group2 = n_group2,
        type = "nested",
        nested_degree = nested_degree,
        nested_min_connectance = nested_min_connectance,
        nested_max_connectance = nested_max_connectance
      )
    }
    
    # -------------------------------------------------------------------------
    # PASSO 2: IDENTIFICAR CORE/PERIPHERY
    # -------------------------------------------------------------------------
    cp_info <- identify_core_periphery_bipartite(
      B = bipartite_net,
      threshold_percentile = threshold_percentile
    )
    
    # -------------------------------------------------------------------------
    # PASSO 3: CONVERTER PARA QUADRADA
    # -------------------------------------------------------------------------
    square_net <- bipartite_to_square(bipartite_net)
    
    # -------------------------------------------------------------------------
    # PASSO 4: CRIAR REDE DE SERVIÇOS ECOSSISTÊMICOS
    # -------------------------------------------------------------------------
    serv_net <- ecosystem_services_network_v2(
      sp_n = n_species_total,
      services_n = n_services,
      mutualistic_network = square_net,
      service_providers = as.character(p$service_prov),
      threshold_percentile = threshold_percentile,
      type = "random",  # Sempre random para serviços
      distribution = "lognormal"
    )
    
    # -------------------------------------------------------------------------
    # PASSO 5: CRIAR AMBIENTE
    # -------------------------------------------------------------------------
    theta <- environment(A_min, A_max, w_min, w_max, t_max = t_max)
    
    # -------------------------------------------------------------------------
    # PASSO 6: PARÂMETROS DAS ESPÉCIES
    # -------------------------------------------------------------------------
    B_vec <- rbeta(n_species_total, B_shape1, B_shape2)
    Ce_vec <- rbeta(n_species_total, Ce_shape1, Ce_shape2)
    Cp_vec <- rbeta(n_species_total, Cp_shape1, Cp_shape2) * Cp_multiplier
    zi <- runif(n_species_total, zi_min, zi_max)
    
    # -------------------------------------------------------------------------
    # PASSO 7: RODAR SIMULAÇÃO
    # -------------------------------------------------------------------------
    dynamics <- simulation(square_net, B_vec, Ce_vec, Cp_vec, zi, theta)
    
    # -------------------------------------------------------------------------
    # PASSO 8: CALCULAR SERVIÇOS ECOSSISTÊMICOS
    # -------------------------------------------------------------------------
    services <- ecosystem(dynamics, serv_net)
    
    # -------------------------------------------------------------------------
    # PASSO 9: EXTRAIR MÉTRICAS ADICIONAIS
    # -------------------------------------------------------------------------
    
    # Número de espécies core e periphery
    n_core_total <- length(cp_info$core_species)
    n_periphery_total <- length(cp_info$periphery_species)
    
    n_core_group1 <- length(cp_info$core_group1)
    n_periphery_group1 <- length(cp_info$periphery_group1)
    
    n_core_group2 <- length(cp_info$core_group2) 
    n_periphery_group2 <- length(cp_info$periphery_group2)
    
    # Persistência separada por core/periphery
    final_state <- dynamics$final_state
    
    # Espécies core que sobreviveram
    core_survived <- sum(final_state[cp_info$core_species])
    core_persistence <- core_survived / n_core_total
    
    # Espécies periphery que sobreviveram
    periphery_survived <- sum(final_state[cp_info$periphery_species])
    periphery_persistence <- periphery_survived / n_periphery_total
    
    # Grau médio inicial por grupo
    mean_degree_core <- mean(cp_info$degree[cp_info$core_species])
    mean_degree_periphery <- mean(cp_info$degree[cp_info$periphery_species])
    
    # Conectância da rede bipartida
    connectance_actual <- sum(bipartite_net) / (n_group1 * n_group2)
    
    # -------------------------------------------------------------------------
    # PASSO 10: ARMAZENAR RESULTADOS
    # -------------------------------------------------------------------------
    results_list[[i]] <- data.frame(
      # IDs
      sim_id = i,
      replicate = p$replicate,
      
      # PARÂMETROS DO GRID
      mut_structure = as.character(p$mut_struct),
      service_providers = as.character(p$service_prov),
      
      # ESTRUTURA DA REDE
      n_group1 = n_group1,
      n_group2 = n_group2,
      n_species_total = n_species_total,
      connectance_actual = connectance_actual,
      n_interactions_bipartite = sum(bipartite_net),
      
      # CORE/PERIPHERY
      n_core_total = n_core_total,
      n_periphery_total = n_periphery_total,
      n_core_group1 = n_core_group1,
      n_periphery_group1 = n_periphery_group1,
      n_core_group2 = n_core_group2,
      n_periphery_group2 = n_periphery_group2,
      mean_degree_core = mean_degree_core,
      mean_degree_periphery = mean_degree_periphery,
      
      # PARÂMETROS AMBIENTAIS
      A_min = A_min,
      A_max = A_max,
      w_min = w_min,
      w_max = w_max,
      env_amplitude = A_max - A_min,
      env_frequency = w_max - w_min,
      
      # RESULTADOS: DINÂMICA GERAL
      persistence_species = dynamics$prop_active_species,
      persistence_interactions = dynamics$prop_remaining_interactions,
      n_species_final = sum(dynamics$final_state),
      time_to_convergence = nrow(dynamics$state_history),
      mean_degree_initial = mean(dynamics$initial_degree),
      
      # RESULTADOS: PERSISTÊNCIA POR GRUPO
      core_persistence = core_persistence,
      periphery_persistence = periphery_persistence,
      core_survived = core_survived,
      periphery_survived = periphery_survived,
      
      # RESULTADOS: SERVIÇOS
      services_initial = sum(services$E_initial),
      services_final = sum(services$E_final),
      services_loss = sum(services$delta_E),
      services_loss_relative = sum(services$delta_E) / sum(services$E_initial),
      
      # HISTÓRICOS (em listas)
      prop_species_history = I(list(dynamics$prop_species_history)),
      prop_interactions_history = I(list(dynamics$prop_interactions_history)),
      services_history = I(list(rowSums(services$services_history))),
      
      stringsAsFactors = FALSE
    )
  }
  
  # ---------------------------------------------------------------------------
  # COMBINAR TODOS OS RESULTADOS
  # ---------------------------------------------------------------------------
  results_df <- bind_rows(results_list)
  
  cat("\n===========================================================\n")
  cat(sprintf("COMPLETO! %d simulações finalizadas.\n", nrow(results_df)))
  cat("===========================================================\n\n")
  
  return(results_df)
}

# =============================================================================
# TESTE RÁPIDO - POUCAS SIMULAÇÕES
# =============================================================================

library(dplyr)

# Teste com apenas 1 replicata de cada combinação
# Total: 3 estruturas × 3 provedores × 1 replicata = 9 simulações
test_results <- explore_parameters_v3(
  mut_structures = c("nested", "modular", "random"),
  service_providers_options = c("core", "periphery", "random"),
  n_group1 = 10,
  n_group2 = 15,
  n_services = 5,
  n_replicates = 1,  # Apenas 1 replicata para teste
  seed = 123
)

# Ver resultados
print(head(test_results))
print(names(test_results))  # Ver todas as colunas

# Ver resumo
summary(test_results %>% 
          select(mut_structure, service_providers, 
                 persistence_species, services_loss_relative))