# =============================================================================
# FUNÇÃO: EXPLORAÇÃO DE PARÂMETROS - VERSÃO 3 (FINAL)
# =============================================================================

explore_parameters_v3 <- function(
    mut_structures = c("nested", "modular", "random"),
    service_providers_options = c("core", "periphery", "random"),
    n_group1 = 15, # Sugestão: aumentado para redes mais realistas
    n_group2 = 25, 
    n_services = 5,
    A_min = 5, A_max = 5, w_min = 0, w_max = 0, t_max = 1000,
    B_shape1 = 0.5, B_shape2 = 0.5,
    Ce_shape1 = 0.5, Ce_shape2 = 0.5,
    Cp_shape1 = 0.5, Cp_shape2 = 0.5, Cp_multiplier = 0, # Custo zero para o teste neutro
    zi_min = 5, zi_max = 5,
    connectance_random = 0.3,
    n_modules = 3,
    internal_connectance_modular = 0.8,
    external_connectance_modular = 0.05,
    nested_degree = 0.8,
    nested_min_connectance = 0.1,
    nested_max_connectance = 0.9,
    threshold_percentile = 0.5,
    n_replicates = 10, 
    seed = 123
) {
  
  # Criar grid de combinações
  params <- expand.grid(
    mut_struct = mut_structures,
    service_prov = service_providers_options,
    replicate = 1:n_replicates,
    stringsAsFactors = FALSE
  )
  
  n_total <- nrow(params)
  n_species_total <- n_group1 + n_group2
  results_list <- list()
  
  cat("\nIniciando simulações...\n")
  
  for(i in 1:n_total) {
    if(i %% 10 == 0 | i == n_total) {
      cat(sprintf("  [%d/%d] %.1f%% completo\n", i, n_total, (i/n_total)*100))
    }
    
    set.seed(seed + i)
    p <- params[i, ]
    
    # PASSO 1: Redes Mutualistas
    if(p$mut_struct == "random") {
      bipartite_net <- mutualistic_network_bipartite(n_group1, n_group2, type = "random", connectance = connectance_random)
    } else if(p$mut_struct == "modular") {
      bipartite_net <- mutualistic_network_bipartite(n_group1, n_group2, type = "modular", n_modules = n_modules, internal_connectance = internal_connectance_modular, external_connectance = external_connectance_modular)
    } else {
      bipartite_net <- mutualistic_network_bipartite(n_group1, n_group2, type = "nested", nested_degree = nested_degree)
    }
    
    # PASSO 2 e 3: Core/Periphery e Conversão
    cp_info <- identify_core_periphery_bipartite(bipartite_net, threshold_percentile)
    square_net <- bipartite_to_square(bipartite_net)
    
    # PASSO 4: Rede de Serviços
    serv_net <- ecosystem_services_network_v2(n_species_total, n_services, square_net, as.character(p$service_prov), threshold_percentile)
    
    # PASSO 5, 6 e 7: Ambiente, Parâmetros e Simulação
    theta <- environment(A_min, A_max, w_min, w_max, t_max)
    B_vec <- rbeta(n_species_total, B_shape1, B_shape2)
    Ce_vec <- rbeta(n_species_total, Ce_shape1, Ce_shape2)
    Cp_vec <- rbeta(n_species_total, Cp_shape1, Cp_shape2) * Cp_multiplier
    zi <- runif(n_species_total, zi_min, zi_max)
    
    dynamics <- simulation(square_net, B_vec, Ce_vec, Cp_vec, zi, theta)
    
    # PASSO 8: Serviços Ecossistêmicos
    services <- ecosystem(dynamics, serv_net)
    e_final_vetor <- services$E_final
    riqueza_final <- sum(e_final_vetor > 0.0001)
    
    # PASSO 9: Métricas
    final_state <- dynamics$final_state
    n_core_total <- length(cp_info$core_species)
    n_periphery_total <- length(cp_info$periphery_species)
    core_survived <- sum(final_state[cp_info$core_species])
    core_persistence <- if(n_core_total > 0) core_survived / n_core_total else 0
    periphery_survived <- sum(final_state[cp_info$periphery_species])
    periphery_persistence <- if(n_periphery_total > 0) periphery_survived / n_periphery_total else 0
    connectance_actual <- sum(bipartite_net) / (n_group1 * n_group2)
    
    # PASSO 10: Armazenar
    temp_df <- data.frame(
      sim_id = i, replicate = p$replicate,
      mut_structure = as.character(p$mut_struct),
      service_providers = as.character(p$service_prov),
      persistence_species = dynamics$prop_active_species,
      core_persistence = core_persistence,
      periphery_persistence = periphery_persistence,
      riqueza_servicos_final = riqueza_final,
      services_total_initial = sum(services$E_initial),
      services_total_final = sum(services$E_final),
      stringsAsFactors = FALSE
    )
    
    serv_cols <- as.data.frame(t(e_final_vetor))
    colnames(serv_cols) <- paste0("serv_", 1:n_services)
    
    results_list[[i]] <- cbind(temp_df, serv_cols)
  } # Fim do Loop i
  
  results_df <- do.call(rbind, results_list)
  cat("\nConcluído!\n")
  return(results_df)
}